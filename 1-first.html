<!DOCTYPE html>
<html> 
  <head> 
    <meta charset="UTF-8"> 
  </head> 
  <body>
    <p>paragraph</p>
    <script> 
//Tipos de javascript
console.log("\nO primeiro operador que vamos conhecer é typeof (atenção: typeof é um OPERADOR UNÁRIO, assim como o operador unário !, e não uma função)")

//primitivos
console.log("\nOs outros dois tipos primitivos são undefined e null")
let undefined_ //undefined
let null_ = null //null
console.log("typeof", undefined_, "=", typeof undefined_)
console.log("typeof", null_, "=", typeof null_, "<- nesse caso typeof deveria retornar null, mas devido a uma cagada na implementação do Javascript, retorna object. null não é object!")

console.log("\nO segundo tipo primitivo é mais easy ainda: boolean")
let boolean = true //boolean
let boolean2 = Boolean('1') //Boolean() will convert values based on if they're truthy or falsy
let boolean3 = Boolean('sapato')
let boolean4 = !!'sapato' //two calls of the ! (logical NOT) operator are equivalent to Boolean()
console.log("typeof", boolean, "=", typeof boolean)
console.log("typeof", boolean2, "=", typeof boolean2)
console.log("typeof", boolean3, "=", typeof boolean3)
console.log("typeof", boolean4, "=", typeof boolean4)

console.log("\nO terceiro tipo primitivo é a String")
let string = "lala"
let string2 = "1"
let string3 = String(3) //String() converts anything into a string, safer than toString
console.log("typeof", string, "=", typeof string)
console.log("typeof", string2, "=", typeof string2)
console.log("typeof", string3, "=", typeof string3)

console.log("\nO último tipo primitivo que vamos conhecer é easy: Number")
console.log("O tipo primitivo Number engloba números inteiros, de ponto flutuante e Not A Number.")
let number = 1 //integer number
let number2 = 1.1 //floating point number
let number3 = NaN //not a number. Despite this, the type is number
let number4 = Number('2') //Number() tries to parse things into numbers
let number5 = Number('shoe') //including values that cannot be type coerced to a number
console.log("typeof", number, "=", typeof number)
console.log("typeof", number2, "=", typeof number2)
console.log("typeof", number3, "=", typeof number3)
console.log("typeof", number4, "=", typeof number4)
console.log("typeof", number5, "=", typeof number5)

//always remember NaN (number), undefined and null, os esquisitos

console.log("\nOperador de potenciação não existe. Usa-se a função Math.pow()")
console.log("Math.pow(2,3) =",Math.pow(2,3))

console.log("\nOperadores bitwise")
/*
 *A sintaxe ES6 para números binários começa com 0b
 *Em Javascript number tem 32 bits e é signed representado por complemento a dois
 *
 *Inverti um número positivo. Que número é agora?
 *  É negativo porque o msb é 1.
 *  Para achar o módulo inverta de volta e some 1 (complemento a dois)
 *
 *Mesmíssima coisa para número negativo
 *
 *2^32 é 4 bilhões
 *2^31 é 2 bilhões
 *2^30 é 1 bilhão
 *  */
let a = 0b1
let b = -2
let c = 0b0

console.log("\nnegação bitwise (negação bitwiser é ~, negação lógica é !")
console.log("~"+a+" =", ~a)
console.log("~"+b+" =", ~b)
console.log("~"+c+" =", ~c)

console.log("\nxor")
console.log(a + "^" + c +" =",a ^ c)
console.log(a + "^" + a +" =",a ^ a)
console.log(c + "^" + c +" =",c ^ c)

console.log("\nzero fill left & right (push zeroes)")
console.log("1 << 31",1<<31) //-2 bilhões
console.log("(1 << 31) >>> 1", (1<<31) >>> 1) //1 bilhão
console.log("(1 << 31) >>> 2", (1<<31) >>> 2) //meio bilhão

console.log("\nsigned right shift (push copies of leftmost bit from the left)")
console.log("1 << 31",1<<31) //-2 bilhões
console.log("(1 << 31) >> 1", (1<<31) >> 1) //-1 bilhão
console.log("(1 << 31) >> 2", (1<<31) >> 2) //-1/2 bilhão
console.log("3 << 30",3<<30) //-1 bilhão
console.log("(3 << 30) >> 1", (3<<30)>>1) //-1/2 bilhão
console.log("(3 << 30) >> 2", (3<<30)>>2) //-1/4 bilhão

console.log("\nTipos não primitivos: Só tem um! Object. Array é um object. Função é um object. Expresão Regular é object.")
let object = {firstname:"miles", lastname:"prower"}
let object2 = [0, 1, 2]
let object3 = new Date()
let object4 = function sum(a,b) { return a+b }
let object5 = /regex/
let object8

console.log("typeof", object, "=", typeof object)
console.log("typeof", object2, "=", typeof object2)
console.log("typeof", object3, "=", typeof object3)
console.log("typeof", object4, "=", typeof object4, "<- uma função é um objeto. Mas o typeof retorna function")
console.log("typeof", object5, "=", typeof object5)

//imprimir no console
console.log("\nUsos do console.log()")
console.log("name:" + object) //concatena tudo numa string. Se for um objeto, vai imprimir o inútil [object Object]
console.log("name:", object) //imprime o conteúdo de um objeto (MUITO ÚTIL)
console.log("number:" + number)
console.log("number:", number) //fica mais arrumado até para um tipo primitivo. Dê preferência à vírgula

//imprimir na página
document.write("<p>"+string+"</p>")
document.write("<h1>"+string+"</h1>")

console.log("\nOperadores lógicos")
console.log("\nnegação lógica")
console.log("!"+a+" =", !a)
console.log("!"+b+" =", !b)
console.log("!"+c+" =", !c)

console.log("\nAvaliação lógica de cada tipo")
console.log("string \"\"", !!"")
console.log("number NaN", !!NaN)
console.log("number 0", !!0)
console.log("number +0", !!+0)
console.log("number -0", !!-0)
console.log("undefined", !!undefined_)
console.log("null", !!null_)
console.log("Só esses são avaliados como false. O resto é true")
console.log("string cheia", !!"0")
console.log("number não zero nem NaN", !!-1)
//fica fácil de decorar se você desenhar os conjuntos
console.log("object é sempre true", !![])
console.log("object é sempre true", !!{})

console.log("\nJavascript tem dois operadores de comparação: loose equality e strict equality")

console.log('O operador == ("loose equality") primeiro verifica se os dois lados são do mesmo tipo. Se forem, realiza a comparação igual ao operador === ("strict equality"). Se forem diferentes, ele primeiro converte para número Strings, Booleanos e Objetos. E só depois compara.')
console.log("number == string", number, string, number == string)
console.log("number == string2", number, string2, number == string2)

console.log("Nesse contexto, um boolean sendo comparado com number, string ou object é convertido com Number(boolean), que retorna 1 ou 0")
console.log("Number(true) =", Number(true))
console.log("Number(false) =", Number(false))

console.log('Nesse contexto, uma string sendo comparada com number ou boolean é convertida com Number(string), que pode retornar um número ou um NaN')
console.log('Number("a") =', Number("a"))
console.log('Number("0") =', Number("0"))

console.log('Nesse contexto, um objeto sendo comparado com number, boolean ou string é convertido para o tipo primitivo mais apropriado: number ou string')
console.log('object =', object)
console.log('Number(object) =', Number(object))
console.log('object.toString() =', object.toString())
console.log('object5 =', object5)
console.log('Number(object5) =', Number(object5))
console.log('object5.toString() =', object5.toString())
console.log('object6 =', object6)
console.log('Number(object6) =', Number(object6))
console.log('object6.toString() =', object6.toString())
console.log('object7 =', object7)
console.log('Number(object7) =', Number(object7))
console.log('object7.toString() =', object7.toString())

console.log("Comparar com NaN dá sempre false. NaN == NaN =", NaN == NaN) //false
console.log("O único caso em que x != x dá true é quando x é NaN:", number3 != number3) //true
console.log("undefined e null dão true se e somente se comparados entre si")
console.log("undefined == undefined", undefined_ == undefined_)
console.log("undefined == null", undefined_ == null_)
console.log("null == null", null_ == null_)

console.log('Daí podem acontecer comparações bizarras como ("a" == true) retornando false, sendo que "a" sozinho avaliaria como true, e true sozinho idem.')
console.log('("a" == true) =', ("a" == true))
console.log('("a" == 1) =', ("a" == 1))
console.log('(NaN == 1) =', (NaN == 1))
console.log('\n("a" == false) =', ("a" == false))
console.log('("a" == 0) =', ("a" == 0))
console.log('(NaN == 0) =', (NaN == 0))

console.log('O operador === ("strict equality") não faz conversão alguma dos operandos antes de compará-los.')
console.log("O único caso em que x !== x dá true é quando x é NaN:", number3 !== number3) //true
console.log("undefined e null não são estritamente iguais:")
console.log("undefined == null", undefined_ == null_)

console.log("A comparação estrita é mais desejável pois seu resultado é mais previsível, além de ser mais rápida por não incorrer em conversões.")

console.log('https://dorey.github.io/JavaScript-Equality-Table/')
console.log('Conclusão: use sempre a comparação estrita ===, a não ser que tenha um bom motivo.')

console.log("Objetos em javascript são simplesmente coleções de pares chave-valor.")
console.log("A primeira forma de criar um objeto inútil é com new Object()")
object8 = new Object()
console.log(object8)
console.log("A segunda forma de criar um objeto inútil é com chaves vazias {}")
object8 = {}
console.log(object8)
console.log("Ou você pode criar um objeto que represente alguma coisa. Lembrando que são apenas pares de chave-valor que podem se encadear.")
object8 = {
  maker: 'Tesla',
  model: 3,
  prices: {
    standard: 50000,
    p90d: 70000
  }
}
console.log(object8)
console.log("OOP: Para criar uma classe, use function, primeira letra maiúscula, e this:")
function Car(maker, model) {
  this.maker = maker
  this.model = model
  this.print = function () {
    console.log(this.maker, this.model)
  }
}
console.log("OOP: Para instanciar a classe, use new:")
object8 = new Car('Tesla', 'Y')
console.log(object8)
object8.print()
console.log("OOP: Por algum motivo dá pra adicionar métodos à classe por fora:")
Car.prototype.printModel = function () {
  console.log(this.model)
}
object8.printModel()
console.log("Adicionar por fora dá a vantagem de que todas as instâncias vão usar a mesma função na memória. Funções declaradas dentro da classe são clonadas para cada instância, usando mais memória.")

/* Em comparação de objetos o que importa é a referência.
 * Um objeto nada mais é do que um conjunto de pares (chave,valor)
 * Um objeto é convertido para um valor primitivo sempre que:
 * - for usado por um operador numérico (+, -, <, etc). É convertido para number.
 * - na impressão de um objeto com console.log(). É convertido para string.
 *
 * */
console.log("\nUma classe com um método privado. Ou seja, cada instância terá seu próprio método na memória:")

function Movie(name, rating) {
  this.name = name
  this.rating = rating
  this.printName = function () {
    console.log(this.name)
  }
}

let movie = new Movie("Deadpool", "R")
console.log(movie)
movie.printName()

console.log("\nUm método público para uma classe. Ou seja, cada instância compartilhará o mesmo método na memória:")

Movie.prototype.printRating = function () {
  console.log(this.rating)
}

console.log('O tipo primitivo Symbol é esquisito porque é criado com construtor, levando uma string opcional só pra facilitar na depuração:')
let symbol = Symbol()
let symbol2 = Symbol("symbol2")
console.log(symbol, symbol2)
console.log('Também é esquisito, porque ao contrário dos outros tipos primitivos, cada símbolo criado é único. Então nunca serão iguais.')
console.log('Symbol() === Symbol(): ', Symbol() === Symbol())
console.log('Símbolos podem ser usados como chaves em objetos. O comando antigo Object.keys(obj) não os lista por questão de retrocompatibilidade, pq antigamente só strings podiam ser chaves:')
const obj = {}
const sym = Symbol('Huayra')
obj[sym] = 'foo'
obj.bar = 'bar'
console.log(obj); // { bar: 'bar' }
console.log(sym in obj); // true
console.log(obj[sym]); // foo
console.log(Object.keys(obj)); // ['bar']
console.log('O método novo Reflect.ownKeys(obj) imprime até as chaves Symbol')
console.log(Reflect.ownKeys(obj));
movie.printRating()
console.log('Como depurar com o Chrome DevTools:', 'https://developer.chrome.com/devtools/docs/javascript-debugging')
    </script>
  </body> 
</html>